;;;;;;;;;;;;
; assignment
;;;;;;;;;;;;

;module
(env-push)

(defmacro assign-type-sym (_) `(sym (str ,_ "_t")))

(defun assign-type-t (_)
	(if (setq _ (find-rev (elem-get 0 _) "bBsSiI"))
		(elem-get _ '(b ub s us i ui)) ""))

(defun assign-src-type (o)
	(case (pop (type-of o))
		(:sym (if (vp-reg? o) :r :c))
		(:num :c)
		(:list
			(cond
				((vp-reg? (defq i (elem-get 0 o)))
					(cond
						((vp-reg? (defq i (elem-get 1 o)))
							(if (= 2 (length o)) :d
								(sym (cat :d (elem-get 2 o)))))
						((/= 2 (length o))
							(sym (cat :i (elem-get 2 o))))
						((num? i) :i)
						((setq i (get (assign-type-sym i)))
							(sym (cat :i (assign-type-t i))))
						(:t :i)))
				((eql i '@) :@)
				((eql i '$) :$)
				((eql i '&)
					(if (vp-reg? (elem-get 1 o))
						(if (vp-reg? (elem-get 2 o)) :&d :&i) :nil))
				(:t :c)))
		(:str :s)))

(defun assign-dst-type (o)
	(case (pop (type-of o))
		(:sym (and (not (vp-reg? o)) (eql (elem-get 0 o) ":") (throw ":reg equate !" o))
			(if (vp-reg? o) :r :k))
		(:list
			(if (vp-reg? (defq i (elem-get 0 o)))
				(cond
					((vp-reg? (defq i (elem-get 1 o)))
						(if (= 2 (length o)) :d
							(sym (cat :d (elem-get 2 o)))))
					((/= 2 (length o))
						(sym (cat :i (elem-get 2 o))))
					((num? i) :i)
					((setq i (get (assign-type-sym i)))
						(sym (cat :i (assign-type-t i))))
					(:t :i))))))

(defun assign-ignored-to-asm ()
	(defq s (list) d (list))
	(each! 0 -1 (lambda (x y)
		(unless (or (eql x y) (eql y '_))
			(push s x) (push d y))) (list src dst))
	(setq src s dst d))

(defun assign-ignored-to-script ()
	(defq s (list) d (list))
	(each! 0 -1 (lambda (x y)
		(unless (eql y "_")
			(push s x) (push d y))) (list src dst))
	(setq src s dst d))

(defun assign-topology-sort ()
	(defq s src d dst i 0 c 1000 l (dec (length d)))
	(while (and (< i l) (/= c 0))
		(if (setq j (unless (list? (defq j (elem-get i d)))
				(some! -1 (inc i) :nil (lambda (s d)
					(cond
						((and (list? s) (find-rev j s)) _)
						((and (list? d) (find-rev j d)) _)
						((eql j s) _))) (list s d))))
			(setq s (rotate s i j (inc j)) d (rotate d i j (inc j)) c (dec c))
			(setq i (inc i))))
	(if (= c 0)
		(throw "Copy cycle detected !" (list s d))
		(setq src s dst d)))

(defun assign-asm-to-asm (src dst)
	(when (/= (length src) (length dst))
		(throw "Mismatching number of src/dst parameters !" (list src dst)))
	(assign-ignored-to-asm)
	(when (> (length dst) 0)
		(if (> (length dst) 1) (assign-topology-sort))
		(each (lambda (x y)
			(case (assign-src-type x)
				(:r (case (assign-dst-type y)
					(:r (vp-cpy-rr x y))
					(:k (def *func_env* y x))
					(:i (vp-cpy-ri x (elem-get 0 y) (elem-get 1 y)))
					(:ii (vp-cpy-ri-i x (elem-get 0 y) (elem-get 1 y)))
					(:is (vp-cpy-ri-s x (elem-get 0 y) (elem-get 1 y)))
					(:ib (vp-cpy-ri-b x (elem-get 0 y) (elem-get 1 y)))
					(:iui (vp-cpy-ri-i x (elem-get 0 y) (elem-get 1 y)))
					(:ius (vp-cpy-ri-s x (elem-get 0 y) (elem-get 1 y)))
					(:iub (vp-cpy-ri-b x (elem-get 0 y) (elem-get 1 y)))
					(:d (vp-cpy-rd x (elem-get 0 y) (elem-get 1 y)))
					(:di (vp-cpy-rd-i x (elem-get 0 y) (elem-get 1 y)))
					(:ds (vp-cpy-rd-s x (elem-get 0 y) (elem-get 1 y)))
					(:db (vp-cpy-rd-b x (elem-get 0 y) (elem-get 1 y)))
					(:dui (vp-cpy-rd-i x (elem-get 0 y) (elem-get 1 y)))
					(:dus (vp-cpy-rd-s x (elem-get 0 y) (elem-get 1 y)))
					(:dub (vp-cpy-rd-b x (elem-get 0 y) (elem-get 1 y)))
					(:t (throw "Invalid dst parameter !" (list x y)))))
				(:c (vp-cpy-cr x y))
				(:i (vp-cpy-ir (elem-get 0 x) (elem-get 1 x) y))
				(:ii (vp-cpy-ir-i (elem-get 0 x) (elem-get 1 x) y))
				(:is (vp-cpy-ir-s (elem-get 0 x) (elem-get 1 x) y))
				(:ib (vp-cpy-ir-b (elem-get 0 x) (elem-get 1 x) y))
				(:iui (vp-cpy-ir-ui (elem-get 0 x) (elem-get 1 x) y))
				(:iub (vp-cpy-ir-ub (elem-get 0 x) (elem-get 1 x) y))
				(:ius (vp-cpy-ir-us (elem-get 0 x) (elem-get 1 x) y))
				(:d (vp-cpy-dr (elem-get 0 x) (elem-get 1 x) y))
				(:di (vp-cpy-dr-i (elem-get 0 x) (elem-get 1 x) y))
				(:ds (vp-cpy-dr-s (elem-get 0 x) (elem-get 1 x) y))
				(:db (vp-cpy-dr-b (elem-get 0 x) (elem-get 1 x) y))
				(:dui (vp-cpy-dr-ui (elem-get 0 x) (elem-get 1 x) y))
				(:dus (vp-cpy-dr-us (elem-get 0 x) (elem-get 1 x) y))
				(:dub (vp-cpy-dr-ub (elem-get 0 x) (elem-get 1 x) y))
				(:&i (vp-lea-i (elem-get 1 x) (elem-get 2 x) y))
				(:&d (vp-lea-d (elem-get 1 x) (elem-get 2 x) y))
				(:@ (fn-bind (elem-get 1 x) y))
				(:s (fn-string x y))
				(:$ (vp-lea-p (elem-get 1 x) y))
				(:t (throw "Invalid src parameter !" (list x y))))) src dst)))

(defun print-inst (_)
	(and (list? _) (not (lambda? (elem-get 0 _))) (print (ascii-char 9) _)))

(defun assign-asm-to-script (src dst _)
	(unless (= (length src) (length (setq dst (map trim (split dst ",")))))
		(throw "Mismatching number of src/dst parameters !" (list src dst)))
	(assign-ignored-to-script)
	(when (/= 0 (length dst))
		(reset-reg-stack (length src))
		(each (# (cscript %0) (compile-arrow)) dst)
		(when *debug_inst*
			(print "pre opt:")
			(each (const print-inst) *inst*))
		(opt-inst-list *inst*)
		(when *debug_inst*
			(print "post opt:")
			(each (const print-inst) *inst*))
		(def-reg-map (reverse src) _)
		(eval *inst* *func_env*)))

(defun assign-script-to-asm (src dst _)
	(unless (= (length (setq src (split src ","))) (length dst))
		(throw "Mismatching number of src/dst parameters !" (list src dst)))
	(when (/= 0 (length dst))
		(reset-reg-stack 0)
		(each (# (cscript %0) (compile-deref?)) src)
		(when *debug_inst*
			(print "pre opt:")
			(each (const print-inst) *inst*))
		(opt-inst-list *inst*)
		(when *debug_inst*
			(print "post opt:")
			(each (const print-inst) *inst*))
		(def-reg-map (cat dst) _)
		(eval *inst* *func_env*)))

(defun assign-script-to-script (src dst _)
	(setq src (split src ",") dst (map trim (split dst ",")))
	(unless (= (length src) (length dst))
		(throw "Mismatching number of src/dst parameters !" (list src dst)))
	(assign-ignored-to-script)
	(when (/= 0 (length dst))
		(reset-reg-stack 0)
		(each cscript src)
		(each-rev (# (cscript %0) (compile-arrow)) dst)
		(when *debug_inst*
			(print "pre opt:")
			(each (const print-inst) *inst*))
		(opt-inst-list *inst*)
		(when *debug_inst*
			(print "post opt:")
			(each (const print-inst) *inst*))
		(def-reg-map :nil _)
		(eval *inst* *func_env*)))

(defun assign (&optional src dst _)
	;optional src, dst, compiler regs
	(if (str? (setq src (opt src '())))
		(if (str? (setq dst (opt dst '())))
			(assign-script-to-script src dst _)
			(assign-script-to-asm src dst _))
		(if (str? (setq dst (opt dst '())))
			(assign-asm-to-script src dst _)
			(assign-asm-to-asm src dst))))

;module
(export-symbols
	assign assign-src-type)
(env-pop)
