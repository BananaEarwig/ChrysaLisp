(include "lib/asm/func.inc")
(include "sys/heap/class.inc")
(include "sys/kernel/class.inc")
(include "sys/pii/class.inc")
(include "gui/gui/class.inc")
(include "class/sym/class.inc")
(include "class/list/class.inc")
(include "gui/region/class.inc")
(include "gui/view/class.inc")
(include "sys/statics/class.inc")

(def-method 'gui :update 16)
	;inputs
	;:r0 = mouse x
	;:r1 = mouse y
	;:r2 = update flags

	(def-vars
		(ptr statics old_stack)
		(struct rect host_gui_rect_size))

	(entry 'gui :update '(:r0 :r1 :r2))

	;kernel callback for update
	(fn-bind 'sys/statics/statics :r3)
	(assign '(:r0 :r1 :r2) '((:r3 statics_gui_mouse_x) (:r3 statics_gui_mouse_y) (:r3 statics_gui_flags)))
	(jump 'sys_task :callback '(0 ($ update_callback)))

(vp-label 'update_callback)
	(vp-cpy-rr :rsp :r0)
	(push-scope)
	(vp-and-cr -16 :rsp)
	(entry {old_stack})

	;statics
	(fn-bind 'sys/statics/statics :r0)
	(assign '(:r0) {statics})

	;inited gui compositor ?
	(vpifnot {statics->statics_gui_init})
		;init
		(assign {0, 0, statics->statics_gui_screen->view_w, statics->statics_gui_screen->view_h}
			{rect.host_gui_rect_x, rect.host_gui_rect_y, rect.host_gui_rect_w, rect.host_gui_rect_h})
		(host-gui-call 'host_gui :init {&rect})
		(assign {1, rect.host_gui_rect_w, rect.host_gui_rect_h}
			{statics->statics_gui_init, statics->statics_gui_screen->view_w, statics->statics_gui_screen->view_h})
	(endif)

	;resize back buffer etc ?
	(vpif {statics->statics_gui_flags})
		;resize back buffer and redraw in full
		(host-gui-call 'host_gui :resize {statics->statics_gui_screen->view_w, statics->statics_gui_screen->view_h})
	(endif)

	;update screen
	(vpif {statics->statics_gui_dirty_flag})
		;render to the backbuffer
		(host-gui-call 'host_gui :begin_composite)
		(call 'gui :composite {statics->statics_gui_screen}
			{rect.host_gui_rect_x, rect.host_gui_rect_y, rect.host_gui_rect_w, rect.host_gui_rect_h})
		(host-gui-call 'host_gui :end_composite)

		;flush backbuffer, clear temps and dirty flag
		(host-gui-call 'host_gui :flush {&rect})
		(call 'list :clear {statics->statics_gui_temps})
		(assign {0} {statics->statics_gui_dirty_flag})
	(endif)

	(assign {old_stack} '(:rsp))
	(pop-scope-syms)
	(return)

(def-func-end)

(def-method 'gui :composite)
	;inputs
	;:r0 = root view object (ptr)
	;outputs
	;:r7 = x (pixels)
	;:r8 = y (pixels)
	;:r9 = width (pixels)
	;:r10 = height (pixels)
	;trashes
	;:r0-:r14
	;info
	;the dirty region bounds is returned for use by the :flush call !

	(def-struct local 0
		(ptr root ctx_flist ctx_next)
		(ptr damaged_region)
		(uint index)
		(int x y w h))

	;save inputs
	(vp-alloc local_size)
	(entry 'gui :composite '(:r0))
	(assign '(:r0) '((:rsp local_root)))

	;iterate through views back to front
	;setting abs cords
	(vp-xor-rr :r7 :r7)
	(vp-xor-rr :r8 :r8)
	(call 'view :backward_tree '(:r0 :r0 ($ abs_down_callback) ($ abs_up_callback)))

	;iterate through views back to front
	;create visible region at root
	(call 'view :backward_tree '(:r0 :r0 ($ visible_down_callback) ($ visible_up_callback)))

	;save bounds for :flush
	(call 'region :bounds '((& :r0 view_dirty_region)) '(x y w h))
	(vp-sub-rr x w)
	(vp-sub-rr y h)
	(assign `(,x ,y ,w ,h) '((:rsp local_x) (:rsp local_y) (:rsp local_w) (:rsp local_h)))

	;iterate through views front to back
	;distribute visible region
	(vp-xor-rr :r1 :r1)
	(assign '(:r1) '((:rsp local_ctx_flist)))
	(call 'view :forward_tree '(:r0 :rsp ($ distribute_down_callback) ($ distribute_up_callback)))

	;draw all views on draw list, and free dirty regions
	(loop-flist :rsp local_ctx_flist :r0 :r0)
		(assign '(:r0) '((:rsp local_ctx_next)))
		(vp-sub-cr view_ctx_node :r0)
		(call 'view :draw '(:r0))
		(assign '((:rsp local_ctx_next)) '(:r1))
		(vp-sub-cr (- view_ctx_node view_dirty_region) :r1)
		(fn-bind 'sys/statics/statics :r0)
		(vp-add-cr statics_gui_rect_heap :r0)
		(call 'region :free '(:r0 :r1))
		(assign '((:rsp local_ctx_next)) '(:r0))
	(loop-end)

	(exit 'gui :composite '((:rsp local_x) (:rsp local_y) (:rsp local_w) (:rsp local_h)))
	(vp-free local_size)
	(vp-ret)

	(vp-def (view user heap x y x1 y1 vx vy vx1 vy1)
		'(:r0 :r1 :r0 :r7 :r8 :r9 :r10 :r11 :r12 :r13 :r14))

(vp-label 'abs_down_callback)
	(entry 'view :forward_tree_callback `(,view ,user))

	(vp-simd vp-cpy-ir-i `(,view ,view) `(,view_x ,view_y) `(,x1 ,y1))
	(vp-simd vp-add-rr `(,x1 ,y1) `(,x ,y))
	(assign `(,x ,y) `((,view view_ctx_x) (,view view_ctx_y)))

	(exit 'view :forward_tree_callback `(,view ,user))
	(vp-ret)

(vp-label 'abs_up_callback)
	(entry 'view :forward_tree_callback `(,view ,user))

	(vp-simd vp-cpy-ir-i `(,view ,view) `(,view_x ,view_y) `(,x1 ,y1))
	(vp-simd vp-sub-rr `(,x1 ,y1) `(,x ,y))

	(exit 'view :forward_tree_callback `(,view ,user))
	(vp-ret)

(vp-label 'visible_down_callback)
	(def-struct vis 0
		(ptr this root next region))

	;save inputs
	(vp-alloc vis_size)
	(entry 'view :forward_tree_callback '((:rsp vis_this) (:rsp vis_root)))

	;region heap
	(fn-bind 'sys/statics/statics heap)
	(vp-add-cr statics_gui_rect_heap heap)

	;remove opaque region from ancestors if not root
	(assign '((:rsp vis_this) (:rsp vis_root)) '(:r1 :r2))
	(vpif '(:r1 /= :r2))
		;remove my opaque region from ancestors
		(vp-xor-rr :r2 :r2)
		(assign '(:r2 (:r1 view_flags)) '((:rsp vis_region) :r3))
		(vp-and-cr view_flag_opaque :r3)
		(vpif '(:r3 /= 0))
			;remove entire view from ancestors
			(vp-simd vp-cpy-cr '(0 0) `(,x ,y))
			(vp-simd vp-cpy-ir-i `(:r1 :r1) `(,view_w ,view_h) `(,x1 ,y1))
			(loop-start)
				(assign '((:r1 hmap_parent)) '(:r2))
				(assign '(:r2) '((:rsp vis_next)))

				;translate region
				(vp-simd vp-cpy-ir-i `(:r1 :r1) `(,view_x ,view_y) `(,vx ,vy))
				(vp-simd vp-cpy-ir-i `(:r2 :r2) `(,view_w ,view_h) `(,vx1 ,vy1))
				(vp-simd vp-add-rr `(,vx ,vy ,vx ,vy) `(,x ,y ,x1 ,y1))

				;clip to parent, exit if clipped away
				(breakif `(,x >= ,vx1) `(,y >= ,vy1) `(,x1 <= 0) `(,y1 <= 0))
				(vp-simd vp-max-cr '(0 0) `(,x ,y))
				(vp-simd vp-min-rr `(,vx1 ,vy1) `(,x1 ,y1))

				;remove opaque region
				(call 'region :remove_rect `(,heap (& :r2 view_dirty_region) ,x ,y ,x1 ,y1) `(,heap))

				(assign '((:rsp vis_next) (:rsp vis_root)) '(:r1 :r2))
			(loop-until '(:r1 = :r2))
		(else)
			;use opaque region, so my opaque area is the visible region
			(assign '((:r1 hmap_parent)) `(:r2))
			(vp-simd vp-cpy-ir-i `(:r1 :r1) `(,view_x ,view_y) `(,x ,y))
			(vp-simd vp-cpy-ir-i `(:r2 :r2) `(,view_w ,view_h) `(,x1 ,y1))
			(vp-simd vp-mul-cr '(-1 -1) `(,x ,y))
			(vp-simd vp-add-rr `(,x ,y) `(,x1 ,y1))
			(vp-add-cr view_opaque_region :r1)
			(call 'region :copy_rect `(,heap :r1 (& :rsp vis_region) ,x ,y ,x1 ,y1) `(,heap))

			;remove from ancestors
			(assign '((:rsp vis_this)) '(:r1))
			(loop-start)
				(assign '((:r1 hmap_parent)) '(:r2))
				(assign '(:r2) '((:rsp vis_next)))

				;exit if clipped away
				(assign '((:rsp vis_region)) '(:r3))
				(breakif '(:r3 = 0))

				;translate temp opaque region
				(vp-simd vp-cpy-ir-i `(:r1 :r1) `(,view_x ,view_y) `(,x ,y))
				(call 'region :translate `((& :rsp vis_region) ,x ,y))

				;clip temp opaque region
				(assign '((:rsp vis_next)) '(:r2))
				(call 'region :clip_rect `(,heap (& :rsp vis_region) 0 0 (:r2 view_w) (:r2 view_h)) `(,heap))

				;remove temp opaque region
				(vp-lea-i :rsp vis_region :r1)
				(assign '((:rsp vis_next)) '(:r2))
				(vp-add-cr view_dirty_region :r2)
				(call 'region :remove_region `(,heap :r1 :r2 0 0) `(,heap))

				(assign '((:rsp vis_next) (:rsp vis_root)) '(:r1 :r2))
			(loop-until '(:r1 = :r2))

			;free any temp region
			(call 'region :free `(,heap (& :rsp vis_region)) `(,heap _))
		(endif)
	(endif)

	(exit 'view :forward_tree_callback `((:rsp vis_this) ,heap))
	(vp-free vis_size)
	(vp-ret)

(vp-label 'visible_up_callback)
	;save inputs
	(vp-alloc vis_size)
	(entry 'view :forward_tree_callback '((:rsp vis_this) (:rsp vis_root)))

	;region heap
	(fn-bind 'sys/statics/statics heap)
	(vp-add-cr statics_gui_rect_heap heap)

	;clip local dirty region with parent bounds
	(assign '((:rsp vis_this) (:rsp vis_root)) '(:r1 :r3))
	(assign '((:r1 hmap_parent)) '(:r2))
	(vpif '(:r1 = :r3))
		(vp-cpy-rr :r1 :r2)
	(endif)
	(vp-simd vp-cpy-ir-i `(:r1 :r1) `(,view_x ,view_y) `(,x ,y))
	(vp-simd vp-cpy-ir-i `(:r2 :r2) `(,view_w ,view_h) `(,x1 ,y1))
	(vp-simd vp-mul-cr '(-1 -1) `(,x ,y))
	(vp-simd vp-add-rr `(,x ,y) `(,x1 ,y1))
	(vp-add-cr view_dirty_region :r1)
	(call 'region :clip_rect `(,heap :r1 ,x ,y ,x1 ,y1) `(,heap))

	;paste local dirty region onto parent if not root
	(assign '((:rsp vis_this) (:rsp vis_root)) '(:r1 :r3))
	(vpif '(:r1 /= :r3))
		(vp-simd vp-cpy-ir-i `(:r1 :r1) `(,view_x ,view_y) `(,x ,y))
		(assign '((:r1 hmap_parent)) `(:r2))
		(vp-simd vp-add-cr `(,view_dirty_region ,view_dirty_region) `(:r1 :r2))
		(call 'region :paste_region `(,heap :r1 :r2 ,x ,y) `(,heap))

		;free local dirty region
		(assign '((:rsp vis_this)) '(:r1))
		(vp-add-cr view_dirty_region :r1)
		(call 'region :free `(,heap :r1) `(,heap _))
	(endif)

	;if dirty all flag then paste entire view onto parent
	(assign '((:rsp vis_this)) '(:r2))
	(assign '((:r2 view_flags)) '(:r3))
	(vp-and-cr view_flag_dirty_all :r3)
	(vpif '(:r3 /= 0))
		;clear dirty all flag
		(assign '((:r2 view_flags)) '(:r3))
		(vp-and-cr (lognot view_flag_dirty_all) :r3)
		(assign '(:r3) `((:r2 view_flags)))
		(vp-simd vp-cpy-ir-i `(:r2 :r2 :r2 :r2)
			`(,view_x ,view_y ,view_w ,view_h)
			`(,x ,y ,x1 ,y1))
		(vp-simd vp-add-rr `(,x ,y) `(,x1 ,y1))
		(assign '((:rsp vis_root) (:r2 hmap_parent)) '(:r3 :r1))
		(vpif '(:r2 = :r3))
			(vp-cpy-rr :r2 :r1)
		(endif)
		(vp-add-cr view_dirty_region :r1)
		(call 'region :paste_rect `(,heap :r1 ,x ,y ,x1 ,y1))
	(endif)

	(exit 'view :forward_tree_callback '((:rsp vis_this) :r1))
	(vp-free vis_size)
	(vp-ret)

(vp-label 'distribute_down_callback)
	(def-struct dist 0
		(ptr this data next))

	;save inputs
	(vp-alloc dist_size)
	(entry 'view :forward_tree_callback '((:rsp dist_this) :r1))
	(assign '(:r1) '((:rsp dist_data)))

	;region heap
	(fn-bind 'sys/statics/statics heap)
	(vp-add-cr statics_gui_rect_heap heap)

	;copy view from parent if not root
	(assign '((:rsp dist_this) (:r1 local_root)) '(:r2 :r3))
	(vpif '(:r2 /= :r3))
		;remove opaque region from ancestors
		(assign '((:r2 hmap_parent)) `(:r1))
		(vp-simd vp-cpy-ir-i `(:r2 :r2 :r2 :r2)
			`(,view_ctx_x ,view_ctx_y ,view_w ,view_h)
			`(,x ,y ,x1 ,y1))
		(vp-simd vp-add-rr `(,x ,y) `(,x1 ,y1))
		(vp-simd vp-add-cr `(,view_dirty_region ,view_dirty_region) `(:r1 :r2))

		;copy my area from parent
		(call 'region :copy_rect `(,heap :r1 :r2 ,x ,y ,x1 ,y1) `(,heap))

		;did we find any opaque region ?
		(assign '((:rsp dist_this)) '(:r2))
		(assign '((:r2 view_dirty_region)) '(:r1))
		(vpif '(:r1 /= 0))
			;remove my opaque region from ancestors
			(assign '((:r2 view_flags)) '(:r3))
			(vp-and-cr view_flag_opaque :r3)
			(vpif '(:r3 /= 0))
				;remove entire view from ancestors
				(loop-start)
					(assign '((:r2 hmap_parent)) '(:r1))
					(assign '(:r1) '((:rsp dist_next)))

					;clip to parent
					(vp-simd vp-cpy-ir-i `(:r1 :r1 :r1 :r1)
						`(,view_ctx_x ,view_ctx_y ,view_w ,view_h)
						`(,vx ,vy ,vx1 ,vy1))
					(vp-simd vp-add-rr `(,vx ,vy) `(,vx1 ,vy1))
					(breakif `(,x >= ,vx1) `(,y >= ,vy1) `(,x1 <= ,vx) `(,y1 <= ,vy))
					(vp-simd vp-max-rr `(,vx ,vy) `(,x ,y))
					(vp-simd vp-min-rr `(,vx1 ,vy1) `(,x1 ,y1))

					(vp-add-cr view_dirty_region :r1)
					(call 'region :remove_rect `(,heap :r1 ,x ,y ,x1 ,y1) `(,heap))

					(assign '((:rsp dist_data) (:rsp dist_next)) '(:r1 :r2))
					(assign '((:r1 local_root)) '(:r1))
				(loop-until '(:r1 = :r2))
			(else)
				;remove opaque region from ancestors
				(assign '(:r2) '(:r1))
				(loop-start)
					(assign '((:r1 hmap_parent)) '(:r2))
					(assign '(:r2) '((:rsp dist_next)))

					(assign '((:rsp dist_this)) '(:r1))
					(vp-simd vp-cpy-ir-i `(:r1 :r1) `(,view_ctx_x ,view_ctx_y) `(,x ,y))
					(vp-add-cr view_opaque_region :r1)
					(vp-add-cr view_dirty_region :r2)
					(call 'region :remove_region `(,heap :r1 :r2 ,x ,y) `(,heap))

					(assign '((:rsp dist_data) (:rsp dist_next)) '(:r2 :r1))
					(assign '((:r2 local_root)) '(:r2))
				(loop-until '(:r1 = :r2))
			(endif)

			;return flag for recursion or not
			(assign '((:rsp dist_this)) '(:r2))
			(assign '((:r2 view_dirty_region)) '(:r1))
		(endif)
	(endif)

	;:r1 will be 0 or not depending on haveing any dirty region
	(exit 'view :forward_tree_callback '((:rsp dist_this) :r1))
	(vp-free dist_size)
	(vp-ret)

(vp-label 'distribute_up_callback)
	;add myself to draw list if not empty
	(entry 'view :forward_tree_callback `(,view :r1))

	(assign `((,view view_dirty_region)) '(:r2))
	(vpif '(:r2 /= 0))
		(vp-lea-i view view_ctx_node :r2)
		(vp-add-cr local_ctx_flist :r1)
		(ln-add-fnode :r1 0 :r2 :r3)
	(endif)

	(exit 'view :forward_tree_callback `(,view :r1))
	(vp-ret)

(def-func-end)
