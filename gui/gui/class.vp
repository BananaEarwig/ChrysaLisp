(include "lib/asm/func.inc")
(include "sys/heap/class.inc")
(include "sys/kernel/class.inc")
(include "sys/pii/class.inc")
(include "gui/gui/class.inc")
(include "class/sym/class.inc")
(include "class/list/class.inc")
(include "gui/region/class.inc")
(include "gui/view/class.inc")
(include "sys/statics/class.inc")

(def-method 'gui :update 16)
	;inputs
	;:r0 = mouse x
	;:r1 = mouse y
	;:r2 = update flags

	(def-vars
		(ptr statics old_stack)
		(struct rect sdl_rect_size))

	(entry 'gui :update '(:r0 :r1 :r2))

	;kernel callback for update
	(fn-bind 'sys/statics/statics :r3)
	(assign '(:r0 :r1 :r2) '((:r3 statics_gui_mouse_x) (:r3 statics_gui_mouse_y) (:r3 statics_gui_flags)))
	(jump 'sys_task :callback '(0 ($ update_callback)))

(vp-label 'update_callback)
	(vp-cpy-rr :rsp :r0)
	(push-scope)
	(vp-and-cr -16 :rsp)
	(entry {old_stack})

	;statics
	(fn-bind 'sys/statics/statics :r0)
	(assign '(:r0) {statics})

	;inited gui compositor ?
	(vpifnot {statics->statics_gui_init})
		;init
		(assign {0, 0, statics->statics_gui_screen->view_w, statics->statics_gui_screen->view_h}
			{rect.sdl_rect_x, rect.sdl_rect_y, rect.sdl_rect_w, rect.sdl_rect_h})
		(host-gui-call 'host_gui :init {&rect})
		(assign {1, rect.sdl_rect_w, rect.sdl_rect_h}
			{statics->statics_gui_init, statics->statics_gui_screen->view_w, statics->statics_gui_screen->view_h})
	(endif)

	;resize back buffer etc ?
	(vpif {statics->statics_gui_flags})
		;resize back buffer and redraw in full
		(host-gui-call 'host_gui :resize {statics->statics_gui_screen->view_w, statics->statics_gui_screen->view_h})
	(endif)

	;update screen
	(vpif {statics->statics_gui_dirty_flag})
		;render to the backbuffer
		(host-gui-call 'host_gui :begin_composite)
		(call 'gui :composite {statics->statics_gui_screen}
			{rect.sdl_rect_x, rect.sdl_rect_y, rect.sdl_rect_w, rect.sdl_rect_h})
		(host-gui-call 'host_gui :end_composite)

		;flush backbuffer, clear temps and dirty flag
		(host-gui-call 'host_gui :flush {&rect})
		(call 'list :clear {statics->statics_gui_temps})
		(assign {0} {statics->statics_gui_dirty_flag})
	(endif)

	(assign {old_stack} '(:rsp))
	(pop-scope-syms)
	(return)

(def-func-end)

(def-method 'gui :composite)
	;inputs
	;:r0 = root view object (ptr)
	;outputs
	;:r7 = x (pixels)
	;:r8 = y (pixels)
	;:r9 = width (pixels)
	;:r10 = height (pixels)
	;trashes
	;:r0-:r14
	;info
	;the dirty region bounds is returned for use by the :flush call !

	(def-struct local 0
		(ptr root ctx_flist ctx_next)
		(ptr damaged_region)
		(uint index)
		(int x y w h))

	;save inputs
	(vp-alloc local_size)
	(entry 'gui :composite '(:r0))
	(assign '(:r0) '((:rsp local_root)))

	;iterate through views back to front
	;setting abs cords
	(vp-xor-rr :r7 :r7)
	(vp-xor-rr :r8 :r8)
	(call 'view :backward_tree '(:r0 :r0 ($ abs_down_callback) ($ abs_up_callback)))

	;iterate through views back to front
	;create visible region at root
	(call 'view :backward_tree '(:r0 :r0 ($ visible_down_callback) ($ visible_up_callback)))

	;save bounds for :flush
	(call 'region :bounds '((& :r0 view_dirty_region)) '(x y w h))
	(vp-sub-rr x w)
	(vp-sub-rr y h)
	(assign `(,x ,y ,w ,h) '((:rsp local_x) (:rsp local_y) (:rsp local_w) (:rsp local_h)))

	;iterate through views front to back
	;distribute visible region
	(vp-xor-rr :r1 :r1)
	(assign '(:r1) '((:rsp local_ctx_flist)))
	(call 'view :forward_tree '(:r0 :rsp ($ distribute_down_callback) ($ distribute_up_callback)))

	;draw all views on draw list, and free dirty regions
	(loop-flist :rsp local_ctx_flist :r0 :r0)
		(assign '(:r0) '((:rsp local_ctx_next)))
		(vp-sub-cr view_ctx_node :r0)
		(call 'view :draw '(:r0))
		(assign '((:rsp local_ctx_next)) '(:r1))
		(vp-sub-cr (- view_ctx_node view_dirty_region) :r1)
		(fn-bind 'sys/statics/statics :r0)
		(vp-add-cr statics_gui_rect_heap :r0)
		(call 'region :free '(:r0 :r1))
		(assign '((:rsp local_ctx_next)) '(:r0))
	(loop-end)

	(exit 'gui :composite '((:rsp local_x) (:rsp local_y) (:rsp local_w) (:rsp local_h)))
	(vp-free local_size)
	(vp-ret)

(vp-label 'abs_down_callback)
	(entry 'view :forward_tree_callback '(:r0 :r1))

	(assign '((:r0 view_x) (:r0 view_y)) '(:r9 :r10))
	(vp-add-rr :r9 :r7)
	(vp-add-rr :r10 :r8)
	(assign '(:r7 :r8) '((:r0 view_ctx_x) (:r0 view_ctx_y)))

	(exit 'view :forward_tree_callback '(:r0 :r1))
	(vp-ret)

(vp-label 'abs_up_callback)
	(entry 'view :forward_tree_callback '(:r0 :r1))

	(assign '((:r0 view_x) (:r0 view_y)) '(:r9 :r10))
	(vp-sub-rr :r9 :r7)
	(vp-sub-rr :r10 :r8)

	(exit 'view :forward_tree_callback '(:r0 :r1))
	(vp-ret)

(vp-label 'visible_down_callback)
	(def-struct vis 0
		(ptr this root next region))

	;save inputs
	(vp-alloc vis_size)
	(entry 'view :forward_tree_callback '((:rsp vis_this) (:rsp vis_root)))

	;region heap
	(fn-bind 'sys/statics/statics :r0)
	(vp-add-cr statics_gui_rect_heap :r0)

	;remove opaque region from ancestors if not root
	(assign '((:rsp vis_this) (:rsp vis_root)) '(:r1 :r2))
	(vpif '(:r1 /= :r2))
		;remove my opaque region from ancestors
		(vp-xor-rr :r2 :r2)
		(assign '(:r2 (:r1 view_flags)) '((:rsp vis_region) :r3))
		(vp-and-cr view_flag_opaque :r3)
		(vpif '(:r3 /= 0))
			;remove entire view from ancestors
			(assign '(0 0 (:r1 view_w) (:r1 view_h)) '(:r7 :r8 :r9 :r10))
			(loop-start)
				(assign '((:r1 hmap_parent)) '(:r2))
				(assign '(:r2) '((:rsp vis_next)))

				;translate region
				(assign '((:r1 view_x) (:r1 view_y) (:r2 view_w) (:r2 view_h)) '(:r11 :r12 :r13 :r14))
				(vp-add-rr :r11 :r7)
				(vp-add-rr :r12 :r8)
				(vp-add-rr :r11 :r9)
				(vp-add-rr :r12 :r10)

				;clip to parent, exit if clipped away
				(breakif '(:r7 >= :r13) '(:r8 >= :r14) '(:r9 <= 0) '(:r10 <= 0))
				(vpif '(:r7 < 0))
					(assign '(0) '(:r7))
				(endif)
				(vpif '(:r8 < 0))
					(assign '(0) '(:r8))
				(endif)
				(vpif '(:r9 > :r13))
					(assign '(:r13) '(:r9))
				(endif)
				(vpif '(:r10 > :r14))
					(assign '(:r14) '(:r10))
				(endif)

				;remove opaque region
				(call 'region :remove_rect '(:r0 (& :r2 view_dirty_region) :r7 :r8 :r9 :r10) '(:r0))

				(assign '((:rsp vis_next) (:rsp vis_root)) '(:r1 :r2))
			(loop-until '(:r1 = :r2))
		(else)
			;use opaque region, so my opaque area is the visible region
			(assign '((:r1 hmap_parent) (:r1 view_x) (:r1 view_y)) '(:r2 :r7 :r8))
			(assign '((:r2 view_w) (:r2 view_h)) '(:r9 :r10))
			(vp-mul-cr -1 :r7)
			(vp-mul-cr -1 :r8)
			(vp-add-rr :r7 :r9)
			(vp-add-rr :r8 :r10)
			(vp-add-cr view_opaque_region :r1)
			(vp-lea-i :rsp vis_region :r2)
			(call 'region :copy_rect '(:r0 :r1 :r2 :r7 :r8 :r9 :r10) '(:r0))

			;remove from ancestors
			(assign '((:rsp vis_this)) '(:r1))
			(loop-start)
				(assign '((:r1 hmap_parent)) '(:r2))
				(assign '(:r2) '((:rsp vis_next)))

				;exit if clipped away
				(assign '((:rsp vis_region)) '(:r3))
				(breakif '(:r3 = 0))

				;translate temp opaque region
				(assign '((:r1 view_x) (:r1 view_y)) '(:r7 :r8))
				(vp-lea-i :rsp vis_region :r1)
				(call 'region :translate '(:r1 :r7 :r8))

				;clip temp opaque region
				(assign '((:rsp vis_next)) '(:r2))
				(vp-lea-i :rsp vis_region :r1)
				(call 'region :clip_rect '(:r0 :r1 0 0 (:r2 view_w) (:r2 view_h)) '(:r0))

				;remove temp opaque region
				(vp-lea-i :rsp vis_region :r1)
				(assign '((:rsp vis_next)) '(:r2))
				(vp-add-cr view_dirty_region :r2)
				(call 'region :remove_region '(:r0 :r1 :r2 0 0) '(:r0))

				(assign '((:rsp vis_next) (:rsp vis_root)) '(:r1 :r2))
			(loop-until '(:r1 = :r2))

			;free any temp region
			(call 'region :free '(:r0 (& :rsp vis_region)) '(:r0))
		(endif)
	(endif)

	(exit 'view :forward_tree_callback '((:rsp vis_this) :r0))
	(vp-free vis_size)
	(vp-ret)

(vp-label 'visible_up_callback)
	;save inputs
	(vp-alloc vis_size)
	(entry 'view :forward_tree_callback '((:rsp vis_this) (:rsp vis_root)))

	;region heap
	(fn-bind 'sys/statics/statics :r0)
	(vp-add-cr statics_gui_rect_heap :r0)

	;clip local dirty region with parent bounds
	(assign '((:rsp vis_this) (:rsp vis_root)) '(:r1 :r3))
	(assign '((:r1 hmap_parent)) '(:r2))
	(vpif '(:r1 = :r3))
		(vp-cpy-rr :r1 :r2)
	(endif)
	(assign '((:r1 view_x) (:r1 view_y) (:r2 view_w) (:r2 view_h)) '(:r7 :r8 :r9 :r10))
	(vp-mul-cr -1 :r7)
	(vp-mul-cr -1 :r8)
	(vp-add-rr :r7 :r9)
	(vp-add-rr :r8 :r10)
	(vp-add-cr view_dirty_region :r1)
	(call 'region :clip_rect '(:r0 :r1 :r7 :r8 :r9 :r10) '(:r0))

	;paste local dirty region onto parent if not root
	(assign '((:rsp vis_this) (:rsp vis_root)) '(:r1 :r3))
	(vpif '(:r1 /= :r3))
		(assign '((:r1 view_x) (:r1 view_y) (:r1 hmap_parent)) '(:r7 :r8 :r2))
		(vp-add-cr view_dirty_region :r1)
		(vp-add-cr view_dirty_region :r2)
		(call 'region :paste_region '(:r0 :r1 :r2 :r7 :r8) '(:r0))

		;free local dirty region
		(assign '((:rsp vis_this)) '(:r1))
		(vp-add-cr view_dirty_region :r1)
		(call 'region :free '(:r0 :r1) '(:r0))
	(endif)

	;if dirty all flag then paste entire view onto parent
	(assign '((:rsp vis_this)) '(:r2))
	(assign '((:r2 view_flags)) '(:r3))
	(vp-and-cr view_flag_dirty_all :r3)
	(vpif '(:r3 /= 0))
		;clear dirty all flag
		(assign '((:r2 view_flags)) '(:r3))
		(vp-and-cr (lognot view_flag_dirty_all) :r3)
		(assign '(:r3 (:r2 view_x) (:r2 view_y) (:r2 view_w) (:r2 view_h)) '((:r2 view_flags) :r7 :r8 :r9 :r10))
		(vp-add-rr :r7 :r9)
		(vp-add-rr :r8 :r10)
		(assign '((:rsp vis_root) (:r2 hmap_parent)) '(:r3 :r1))
		(vpif '(:r2 = :r3))
			(vp-cpy-rr :r2 :r1)
		(endif)
		(vp-add-cr view_dirty_region :r1)
		(call 'region :paste_rect '(:r0 :r1 :r7 :r8 :r9 :r10))
	(endif)

	(exit 'view :forward_tree_callback '((:rsp vis_this) :r1))
	(vp-free vis_size)
	(vp-ret)

(vp-label 'distribute_down_callback)
	(def-struct dist 0
		(ptr this data next))

	;save inputs
	(vp-alloc dist_size)
	(entry 'view :forward_tree_callback '((:rsp dist_this) :r1))
	(assign '(:r1) '((:rsp dist_data)))

	;region heap
	(fn-bind 'sys/statics/statics :r0)
	(vp-add-cr statics_gui_rect_heap :r0)

	;copy view from parent if not root
	(assign '((:rsp dist_this) (:r1 local_root)) '(:r2 :r3))
	(vpif '(:r2 /= :r3))
		;remove opaque region from ancestors
		(assign '((:r2 hmap_parent) (:r2 view_ctx_x) (:r2 view_ctx_y)
			(:r2 view_w) (:r2 view_h)) '(:r1 :r7 :r8 :r9 :r10))
		(vp-add-rr :r7 :r9)
		(vp-add-rr :r8 :r10)
		(vp-add-cr view_dirty_region :r1)
		(vp-add-cr view_dirty_region :r2)

		;copy my area from parent
		(call 'region :copy_rect '(:r0 :r1 :r2 :r7 :r8 :r9 :r10) '(:r0))

		;did we find any opaque region ?
		(assign '((:rsp dist_this)) '(:r2))
		(assign '((:r2 view_dirty_region)) '(:r1))
		(vpif '(:r1 /= 0))
			;remove my opaque region from ancestors
			(assign '((:r2 view_flags)) '(:r3))
			(vp-and-cr view_flag_opaque :r3)
			(vpif '(:r3 /= 0))
				;remove entire view from ancestors
				(loop-start)
					(assign '((:r2 hmap_parent)) '(:r1))
					(assign '(:r1) '((:rsp dist_next)))

					;clip to parent
					(assign '((:r1 view_ctx_x) (:r1 view_ctx_y) (:r1 view_w) (:r1 view_h)) '(:r11 :r12 :r13 :r14))
					(vp-add-rr :r11 :r13)
					(vp-add-rr :r12 :r14)
					(breakif '(:r7 >= :r13) '(:r8 >= :r14) '(:r9 <= :r11) '(:r10 <= :r12))
					(vpif '(:r7 < :r11))
						(assign '(:r11) '(:r7))
					(endif)
					(vpif '(:r8 < :r12))
						(assign '(:r12) '(:r8))
					(endif)
					(vpif '(:r9 > :r13))
						(assign '(:r13) '(:r9))
					(endif)
					(vpif '(:r10 > :r14))
						(assign '(:r14) '(:r10))
					(endif)

					(vp-add-cr view_dirty_region :r1)
					(call 'region :remove_rect '(:r0 :r1 :r7 :r8 :r9 :r10) '(:r0))

					(assign '((:rsp dist_data) (:rsp dist_next)) '(:r1 :r2))
					(assign '((:r1 local_root)) '(:r1))
				(loop-until '(:r1 = :r2))
			(else)
				;remove opaque region from ancestors
				(assign '(:r2) '(:r1))
				(loop-start)
					(assign '((:r1 hmap_parent)) '(:r2))
					(assign '(:r2) '((:rsp dist_next)))

					(assign '((:rsp dist_this)) '(:r1))
					(assign '((:r1 view_ctx_x) (:r1 view_ctx_y)) '(:r7 :r8))
					(vp-add-cr view_opaque_region :r1)
					(vp-add-cr view_dirty_region :r2)
					(call 'region :remove_region '(:r0 :r1 :r2 :r7 :r8) '(:r0))

					(assign '((:rsp dist_data) (:rsp dist_next)) '(:r2 :r1))
					(assign '((:r2 local_root)) '(:r2))
				(loop-until '(:r1 = :r2))
			(endif)

			;return flag for recursion or not
			(assign '((:rsp dist_this)) '(:r2))
			(assign '((:r2 view_dirty_region)) '(:r1))
		(endif)
	(endif)

	;:r1 will be 0 or not depending on haveing any dirty region
	(exit 'view :forward_tree_callback '((:rsp dist_this) :r1))
	(vp-free dist_size)
	(vp-ret)

(vp-label 'distribute_up_callback)
	;add myself to draw list if not empty
	(entry 'view :forward_tree_callback '(:r0 :r1))

	(assign '((:r0 view_dirty_region)) '(:r2))
	(vpif '(:r2 /= 0))
		(vp-lea-i :r0 view_ctx_node :r2)
		(vp-add-cr local_ctx_flist :r1)
		(ln-add-fnode :r1 0 :r2 :r3)
	(endif)

	(exit 'view :forward_tree_callback '(:r0 :r1))
	(vp-ret)

(def-func-end)
